// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for CreatePromptRequest0Type.
const (
	CreatePromptRequest0TypeChat CreatePromptRequest0Type = "chat"
)

// Defines values for CreatePromptRequest1Type.
const (
	CreatePromptRequest1TypeText CreatePromptRequest1Type = "text"
)

// Defines values for DatasetStatus.
const (
	ACTIVE   DatasetStatus = "ACTIVE"
	ARCHIVED DatasetStatus = "ARCHIVED"
)

// Defines values for IngestionEvent0Type.
const (
	TraceCreate IngestionEvent0Type = "trace-create"
)

// Defines values for IngestionEvent1Type.
const (
	ScoreCreate IngestionEvent1Type = "score-create"
)

// Defines values for IngestionEvent2Type.
const (
	SpanCreate IngestionEvent2Type = "span-create"
)

// Defines values for IngestionEvent3Type.
const (
	SpanUpdate IngestionEvent3Type = "span-update"
)

// Defines values for IngestionEvent4Type.
const (
	GenerationCreate IngestionEvent4Type = "generation-create"
)

// Defines values for IngestionEvent5Type.
const (
	GenerationUpdate IngestionEvent5Type = "generation-update"
)

// Defines values for IngestionEvent6Type.
const (
	EventCreate IngestionEvent6Type = "event-create"
)

// Defines values for IngestionEvent7Type.
const (
	SdkLog IngestionEvent7Type = "sdk-log"
)

// Defines values for IngestionEvent8Type.
const (
	ObservationCreate IngestionEvent8Type = "observation-create"
)

// Defines values for IngestionEvent9Type.
const (
	ObservationUpdate IngestionEvent9Type = "observation-update"
)

// Defines values for ModelUsageUnit.
const (
	CHARACTERS   ModelUsageUnit = "CHARACTERS"
	IMAGES       ModelUsageUnit = "IMAGES"
	MILLISECONDS ModelUsageUnit = "MILLISECONDS"
	REQUESTS     ModelUsageUnit = "REQUESTS"
	SECONDS      ModelUsageUnit = "SECONDS"
	TOKENS       ModelUsageUnit = "TOKENS"
)

// Defines values for ObservationLevel.
const (
	DEBUG   ObservationLevel = "DEBUG"
	DEFAULT ObservationLevel = "DEFAULT"
	ERROR   ObservationLevel = "ERROR"
	WARNING ObservationLevel = "WARNING"
)

// Defines values for ObservationType.
const (
	EVENT      ObservationType = "EVENT"
	GENERATION ObservationType = "GENERATION"
	SPAN       ObservationType = "SPAN"
)

// Defines values for Prompt0Type.
const (
	Prompt0TypeChat Prompt0Type = "chat"
)

// Defines values for Prompt1Type.
const (
	Prompt1TypeText Prompt1Type = "text"
)

// Defines values for Score0DataType.
const (
	Score0DataTypeNUMERIC Score0DataType = "NUMERIC"
)

// Defines values for Score1DataType.
const (
	CATEGORICAL Score1DataType = "CATEGORICAL"
)

// Defines values for Score2DataType.
const (
	BOOLEAN Score2DataType = "BOOLEAN"
)

// Defines values for ScoreDataType.
const (
	ScoreDataTypeBOOLEAN     ScoreDataType = "BOOLEAN"
	ScoreDataTypeCATEGORICAL ScoreDataType = "CATEGORICAL"
	ScoreDataTypeNUMERIC     ScoreDataType = "NUMERIC"
)

// Defines values for ScoreSource.
const (
	ANNOTATION ScoreSource = "ANNOTATION"
	API        ScoreSource = "API"
	EVAL       ScoreSource = "EVAL"
)

// BaseEvent defines model for BaseEvent.
type BaseEvent struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string `json:"timestamp"`
}

// BasePrompt defines model for BasePrompt.
type BasePrompt struct {
	Config interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string `json:"tags"`
	Version int      `json:"version"`
}

// BaseScore defines model for BaseScore.
type BaseScore struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId      *string     `json:"configId"`
	CreatedAt     time.Time   `json:"createdAt"`
	Id            string      `json:"id"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`
	Source        ScoreSource `json:"source"`
	Timestamp     time.Time   `json:"timestamp"`
	TraceId       string      `json:"traceId"`
	UpdatedAt     time.Time   `json:"updatedAt"`
}

// BooleanScore defines model for BooleanScore.
type BooleanScore = BaseScore

// CategoricalScore defines model for CategoricalScore.
type CategoricalScore = BaseScore

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

// ChatPrompt defines model for ChatPrompt.
type ChatPrompt = BasePrompt

// ConfigCategory defines model for ConfigCategory.
type ConfigCategory struct {
	Label string  `json:"label"`
	Value float64 `json:"value"`
}

// CreateChatPromptRequest defines model for CreateChatPromptRequest.
type CreateChatPromptRequest struct {
	Config *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string     `json:"labels"`
	Name   string        `json:"name"`
	Prompt []ChatMessage `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// CreateDatasetItemRequest defines model for CreateDatasetItemRequest.
type CreateDatasetItemRequest struct {
	DatasetName    string       `json:"datasetName"`
	ExpectedOutput *interface{} `json:"expectedOutput"`

	// Id Dataset items are upserted on their id. Id needs to be unique (project-level) and cannot be reused across datasets.
	Id                  *string        `json:"id"`
	Input               *interface{}   `json:"input"`
	Metadata            *interface{}   `json:"metadata"`
	SourceObservationId *string        `json:"sourceObservationId"`
	SourceTraceId       *string        `json:"sourceTraceId"`
	Status              *DatasetStatus `json:"status,omitempty"`
}

// CreateDatasetRequest defines model for CreateDatasetRequest.
type CreateDatasetRequest struct {
	Description *string      `json:"description"`
	Metadata    *interface{} `json:"metadata"`
	Name        string       `json:"name"`
}

// CreateDatasetRunItemRequest defines model for CreateDatasetRunItemRequest.
type CreateDatasetRunItemRequest struct {
	DatasetItemId string `json:"datasetItemId"`

	// Metadata Metadata of the dataset run, updates run if run already exists
	Metadata      *interface{} `json:"metadata"`
	ObservationId *string      `json:"observationId"`

	// RunDescription Description of the run. If run exists, description will be updated.
	RunDescription *string `json:"runDescription"`
	RunName        string  `json:"runName"`

	// TraceId traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId.
	TraceId *string `json:"traceId"`
}

// CreateEventBody defines model for CreateEventBody.
type CreateEventBody = OptionalObservationBody

// CreateEventEvent defines model for CreateEventEvent.
type CreateEventEvent = BaseEvent

// CreateGenerationBody defines model for CreateGenerationBody.
type CreateGenerationBody = CreateSpanBody

// CreateGenerationEvent defines model for CreateGenerationEvent.
type CreateGenerationEvent = BaseEvent

// CreateModelRequest defines model for CreateModelRequest.
type CreateModelRequest struct {
	// InputPrice Price (USD) per input unit
	InputPrice *float64 `json:"inputPrice"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *string `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig *interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Price (USD) per total units. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit ModelUsageUnit `json:"unit"`
}

// CreateObservationEvent defines model for CreateObservationEvent.
type CreateObservationEvent = BaseEvent

// CreatePromptRequest defines model for CreatePromptRequest.
type CreatePromptRequest struct {
	union json.RawMessage
}

// CreatePromptRequest0 defines model for .
type CreatePromptRequest0 struct {
	Config *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string     `json:"labels"`
	Name   string        `json:"name"`
	Prompt []ChatMessage `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest0Type `json:"type,omitempty"`
}

// CreatePromptRequest0Type defines model for CreatePromptRequest.0.Type.
type CreatePromptRequest0Type string

// CreatePromptRequest1 defines model for .
type CreatePromptRequest1 struct {
	Config *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest1Type `json:"type,omitempty"`
}

// CreatePromptRequest1Type defines model for CreatePromptRequest.1.Type.
type CreatePromptRequest1Type string

// CreateScoreConfigRequest defines model for CreateScoreConfigRequest.
type CreateScoreConfigRequest struct {
	// Categories Configure custom categories for categorical scores. Pass a list of objects with `label` and `value` properties. Categories are autogenerated for boolean configs and cannot be passed
	Categories *[]ConfigCategory `json:"categories"`
	DataType   ScoreDataType     `json:"dataType"`

	// Description Description is shown across the Langfuse UI and can be used to e.g. explain the config categories in detail, why a numeric range was set, or provide additional context on config name or usage
	Description *string `json:"description"`

	// MaxValue Configure a maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Configure a minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue *float64 `json:"minValue"`
	Name     string   `json:"name"`
}

// CreateScoreRequest defines model for CreateScoreRequest.
type CreateScoreRequest struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. The unique langfuse identifier of a score config. When passing this field, the dataType and stringValue fields are automatically populated.
	ConfigId      *string        `json:"configId"`
	DataType      *ScoreDataType `json:"dataType,omitempty"`
	Id            *string        `json:"id"`
	Name          string         `json:"name"`
	ObservationId *string        `json:"observationId"`
	TraceId       string         `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// CreateScoreResponse defines model for CreateScoreResponse.
type CreateScoreResponse struct {
	// Id The id of the created object in Langfuse
	Id string `json:"id"`
}

// CreateScoreValue The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
type CreateScoreValue struct {
	union json.RawMessage
}

// CreateScoreValue0 defines model for .
type CreateScoreValue0 = float64

// CreateScoreValue1 defines model for .
type CreateScoreValue1 = string

// CreateSpanBody defines model for CreateSpanBody.
type CreateSpanBody = CreateEventBody

// CreateSpanEvent defines model for CreateSpanEvent.
type CreateSpanEvent = BaseEvent

// CreateTextPromptRequest defines model for CreateTextPromptRequest.
type CreateTextPromptRequest struct {
	Config *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// DailyMetrics defines model for DailyMetrics.
type DailyMetrics struct {
	// Data A list of daily metrics, only days with ingested data are included.
	Data []DailyMetricsDetails `json:"data"`
	Meta UtilsMetaResponse     `json:"meta"`
}

// DailyMetricsDetails defines model for DailyMetricsDetails.
type DailyMetricsDetails struct {
	CountObservations int    `json:"countObservations"`
	CountTraces       int    `json:"countTraces"`
	Date              string `json:"date"`

	// TotalCost Total model cost in USD
	TotalCost float64        `json:"totalCost"`
	Usage     []UsageByModel `json:"usage"`
}

// Dataset defines model for Dataset.
type Dataset struct {
	CreatedAt   time.Time    `json:"createdAt"`
	Description *string      `json:"description"`
	Id          string       `json:"id"`
	Metadata    *interface{} `json:"metadata"`
	Name        string       `json:"name"`
	ProjectId   string       `json:"projectId"`
	UpdatedAt   time.Time    `json:"updatedAt"`
}

// DatasetItem defines model for DatasetItem.
type DatasetItem struct {
	CreatedAt           time.Time     `json:"createdAt"`
	DatasetId           string        `json:"datasetId"`
	DatasetName         string        `json:"datasetName"`
	ExpectedOutput      *interface{}  `json:"expectedOutput"`
	Id                  string        `json:"id"`
	Input               *interface{}  `json:"input"`
	Metadata            *interface{}  `json:"metadata"`
	SourceObservationId *string       `json:"sourceObservationId"`
	SourceTraceId       *string       `json:"sourceTraceId"`
	Status              DatasetStatus `json:"status"`
	UpdatedAt           time.Time     `json:"updatedAt"`
}

// DatasetRun defines model for DatasetRun.
type DatasetRun struct {
	CreatedAt   time.Time    `json:"createdAt"`
	DatasetId   string       `json:"datasetId"`
	DatasetName string       `json:"datasetName"`
	Description *string      `json:"description"`
	Id          string       `json:"id"`
	Metadata    *interface{} `json:"metadata"`
	Name        string       `json:"name"`
	UpdatedAt   time.Time    `json:"updatedAt"`
}

// DatasetRunItem defines model for DatasetRunItem.
type DatasetRunItem struct {
	CreatedAt      time.Time `json:"createdAt"`
	DatasetItemId  string    `json:"datasetItemId"`
	DatasetRunId   string    `json:"datasetRunId"`
	DatasetRunName string    `json:"datasetRunName"`
	Id             string    `json:"id"`
	ObservationId  *string   `json:"observationId"`
	TraceId        string    `json:"traceId"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// DatasetRunWithItems defines model for DatasetRunWithItems.
type DatasetRunWithItems = DatasetRun

// DatasetStatus defines model for DatasetStatus.
type DatasetStatus string

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status string `json:"status"`

	// Version Langfuse server version
	Version string `json:"version"`
}

// IngestionError defines model for IngestionError.
type IngestionError struct {
	Error   *interface{} `json:"error"`
	Id      string       `json:"id"`
	Message *string      `json:"message"`
	Status  int          `json:"status"`
}

// IngestionEvent defines model for IngestionEvent.
type IngestionEvent struct {
	union json.RawMessage
}

// IngestionEvent0 defines model for .
type IngestionEvent0 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent0Type `json:"type,omitempty"`
}

// IngestionEvent0Type defines model for IngestionEvent.0.Type.
type IngestionEvent0Type string

// IngestionEvent1 defines model for .
type IngestionEvent1 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent1Type `json:"type,omitempty"`
}

// IngestionEvent1Type defines model for IngestionEvent.1.Type.
type IngestionEvent1Type string

// IngestionEvent2 defines model for .
type IngestionEvent2 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent2Type `json:"type,omitempty"`
}

// IngestionEvent2Type defines model for IngestionEvent.2.Type.
type IngestionEvent2Type string

// IngestionEvent3 defines model for .
type IngestionEvent3 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent3Type `json:"type,omitempty"`
}

// IngestionEvent3Type defines model for IngestionEvent.3.Type.
type IngestionEvent3Type string

// IngestionEvent4 defines model for .
type IngestionEvent4 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent4Type `json:"type,omitempty"`
}

// IngestionEvent4Type defines model for IngestionEvent.4.Type.
type IngestionEvent4Type string

// IngestionEvent5 defines model for .
type IngestionEvent5 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent5Type `json:"type,omitempty"`
}

// IngestionEvent5Type defines model for IngestionEvent.5.Type.
type IngestionEvent5Type string

// IngestionEvent6 defines model for .
type IngestionEvent6 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent6Type `json:"type,omitempty"`
}

// IngestionEvent6Type defines model for IngestionEvent.6.Type.
type IngestionEvent6Type string

// IngestionEvent7 defines model for .
type IngestionEvent7 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent7Type `json:"type,omitempty"`
}

// IngestionEvent7Type defines model for IngestionEvent.7.Type.
type IngestionEvent7Type string

// IngestionEvent8 defines model for .
type IngestionEvent8 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent8Type `json:"type,omitempty"`
}

// IngestionEvent8Type defines model for IngestionEvent.8.Type.
type IngestionEvent8Type string

// IngestionEvent9 defines model for .
type IngestionEvent9 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent9Type `json:"type,omitempty"`
}

// IngestionEvent9Type defines model for IngestionEvent.9.Type.
type IngestionEvent9Type string

// IngestionResponse defines model for IngestionResponse.
type IngestionResponse struct {
	Errors    []IngestionError   `json:"errors"`
	Successes []IngestionSuccess `json:"successes"`
}

// IngestionSuccess defines model for IngestionSuccess.
type IngestionSuccess struct {
	Id     string `json:"id"`
	Status int    `json:"status"`
}

// IngestionUsage defines model for IngestionUsage.
type IngestionUsage struct {
	union json.RawMessage
}

// MapValue defines model for MapValue.
type MapValue struct {
	union json.RawMessage
}

// MapValue0 defines model for .
type MapValue0 = string

// MapValue1 defines model for .
type MapValue1 = int

// MapValue2 defines model for .
type MapValue2 = bool

// MapValue3 defines model for .
type MapValue3 = []string

// Model Model definition used for transforming usage into USD cost and/or tokenization.
type Model struct {
	Id string `json:"id"`

	// InputPrice Price (USD) per input unit
	InputPrice        *float64 `json:"inputPrice"`
	IsLangfuseManaged bool     `json:"isLangfuseManaged"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *string `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig *interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Price (USD) per total unit. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit ModelUsageUnit `json:"unit"`
}

// ModelUsageUnit Unit of usage in Langfuse
type ModelUsageUnit string

// NumericScore defines model for NumericScore.
type NumericScore = BaseScore

// Observation defines model for Observation.
type Observation struct {
	CompletionStartTime *time.Time           `json:"completionStartTime"`
	EndTime             *time.Time           `json:"endTime"`
	Id                  string               `json:"id"`
	Input               *interface{}         `json:"input"`
	Level               ObservationLevel     `json:"level"`
	Metadata            *interface{}         `json:"metadata"`
	Model               *string              `json:"model"`
	ModelParameters     *map[string]MapValue `json:"modelParameters"`
	Name                *string              `json:"name"`
	Output              *interface{}         `json:"output"`
	ParentObservationId *string              `json:"parentObservationId"`
	PromptId            *string              `json:"promptId"`
	StartTime           time.Time            `json:"startTime"`
	StatusMessage       *string              `json:"statusMessage"`
	TraceId             *string              `json:"traceId"`
	Type                string               `json:"type"`

	// Usage Standard interface for usage and cost
	Usage   *Usage  `json:"usage,omitempty"`
	Version *string `json:"version"`
}

// ObservationBody defines model for ObservationBody.
type ObservationBody struct {
	CompletionStartTime *time.Time           `json:"completionStartTime"`
	EndTime             *time.Time           `json:"endTime"`
	Id                  *string              `json:"id"`
	Input               *interface{}         `json:"input"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	Metadata            *interface{}         `json:"metadata"`
	Model               *string              `json:"model"`
	ModelParameters     *map[string]MapValue `json:"modelParameters"`
	Name                *string              `json:"name"`
	Output              *interface{}         `json:"output"`
	ParentObservationId *string              `json:"parentObservationId"`
	StartTime           *time.Time           `json:"startTime"`
	StatusMessage       *string              `json:"statusMessage"`
	TraceId             *string              `json:"traceId"`
	Type                ObservationType      `json:"type"`

	// Usage Standard interface for usage and cost
	Usage   *Usage  `json:"usage,omitempty"`
	Version *string `json:"version"`
}

// ObservationLevel defines model for ObservationLevel.
type ObservationLevel string

// ObservationType defines model for ObservationType.
type ObservationType string

// ObservationsView defines model for ObservationsView.
type ObservationsView = Observation

// ObservationsViews defines model for ObservationsViews.
type ObservationsViews struct {
	Data []ObservationsView `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// OpenAIUsage Usage interface of OpenAI for improved compatibility.
type OpenAIUsage struct {
	CompletionTokens *int `json:"completionTokens"`
	PromptTokens     *int `json:"promptTokens"`
	TotalTokens      *int `json:"totalTokens"`
}

// OptionalObservationBody defines model for OptionalObservationBody.
type OptionalObservationBody struct {
	Input               *interface{}      `json:"input"`
	Level               *ObservationLevel `json:"level,omitempty"`
	Metadata            *interface{}      `json:"metadata"`
	Name                *string           `json:"name"`
	Output              *interface{}      `json:"output"`
	ParentObservationId *string           `json:"parentObservationId"`
	StartTime           *time.Time        `json:"startTime"`
	StatusMessage       *string           `json:"statusMessage"`
	TraceId             *string           `json:"traceId"`
	Version             *string           `json:"version"`
}

// PaginatedDatasetItems defines model for PaginatedDatasetItems.
type PaginatedDatasetItems struct {
	Data []DatasetItem     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetRuns defines model for PaginatedDatasetRuns.
type PaginatedDatasetRuns struct {
	Data []DatasetRun      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasets defines model for PaginatedDatasets.
type PaginatedDatasets struct {
	Data []Dataset         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedModels defines model for PaginatedModels.
type PaginatedModels struct {
	Data []Model           `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedSessions defines model for PaginatedSessions.
type PaginatedSessions struct {
	Data []Session         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// Project defines model for Project.
type Project struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// Projects defines model for Projects.
type Projects struct {
	Data []Project `json:"data"`
}

// Prompt defines model for Prompt.
type Prompt struct {
	union json.RawMessage
}

// Prompt0 defines model for .
type Prompt0 struct {
	Config interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt0Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt0Type defines model for Prompt.0.Type.
type Prompt0Type string

// Prompt1 defines model for .
type Prompt1 struct {
	Config interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt1Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt1Type defines model for Prompt.1.Type.
type Prompt1Type string

// PromptMeta defines model for PromptMeta.
type PromptMeta struct {
	Labels   []string `json:"labels"`
	Name     string   `json:"name"`
	Tags     []string `json:"tags"`
	Versions []int    `json:"versions"`
}

// PromptMetaListResponse defines model for PromptMetaListResponse.
type PromptMetaListResponse struct {
	Data []PromptMeta      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// SDKLogBody defines model for SDKLogBody.
type SDKLogBody struct {
	Log interface{} `json:"log"`
}

// SDKLogEvent defines model for SDKLogEvent.
type SDKLogEvent = BaseEvent

// Score defines model for Score.
type Score struct {
	union json.RawMessage
}

// Score0 defines model for .
type Score0 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId      *string         `json:"configId"`
	CreatedAt     time.Time       `json:"createdAt"`
	DataType      *Score0DataType `json:"dataType,omitempty"`
	Id            string          `json:"id"`
	Name          string          `json:"name"`
	ObservationId *string         `json:"observationId"`
	Source        ScoreSource     `json:"source"`
	Timestamp     time.Time       `json:"timestamp"`
	TraceId       string          `json:"traceId"`
	UpdatedAt     time.Time       `json:"updatedAt"`
}

// Score0DataType defines model for Score.0.DataType.
type Score0DataType string

// Score1 defines model for .
type Score1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId      *string         `json:"configId"`
	CreatedAt     time.Time       `json:"createdAt"`
	DataType      *Score1DataType `json:"dataType,omitempty"`
	Id            string          `json:"id"`
	Name          string          `json:"name"`
	ObservationId *string         `json:"observationId"`
	Source        ScoreSource     `json:"source"`
	Timestamp     time.Time       `json:"timestamp"`
	TraceId       string          `json:"traceId"`
	UpdatedAt     time.Time       `json:"updatedAt"`
}

// Score1DataType defines model for Score.1.DataType.
type Score1DataType string

// Score2 defines model for .
type Score2 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId      *string         `json:"configId"`
	CreatedAt     time.Time       `json:"createdAt"`
	DataType      *Score2DataType `json:"dataType,omitempty"`
	Id            string          `json:"id"`
	Name          string          `json:"name"`
	ObservationId *string         `json:"observationId"`
	Source        ScoreSource     `json:"source"`
	Timestamp     time.Time       `json:"timestamp"`
	TraceId       string          `json:"traceId"`
	UpdatedAt     time.Time       `json:"updatedAt"`
}

// Score2DataType defines model for Score.2.DataType.
type Score2DataType string

// ScoreBody defines model for ScoreBody.
type ScoreBody struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, the score name must equal the config name and scores must comply with the config's range and data type. For categorical scores, the value must map to a config category. Numeric scores might be constrained by the score config's max and min values
	ConfigId      *string        `json:"configId"`
	DataType      *ScoreDataType `json:"dataType,omitempty"`
	Id            *string        `json:"id"`
	Name          string         `json:"name"`
	ObservationId *string        `json:"observationId"`
	TraceId       string         `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// ScoreConfig Configuration for a score
type ScoreConfig struct {
	// Categories Configures custom categories for categorical scores
	Categories  *[]ConfigCategory `json:"categories"`
	CreatedAt   time.Time         `json:"createdAt"`
	DataType    ScoreDataType     `json:"dataType"`
	Description *string           `json:"description"`
	Id          string            `json:"id"`

	// IsArchived Whether the score config is archived. Defaults to false
	IsArchived bool `json:"isArchived"`

	// MaxValue Sets maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Sets minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue  *float64  `json:"minValue"`
	Name      string    `json:"name"`
	ProjectId string    `json:"projectId"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// ScoreConfigs defines model for ScoreConfigs.
type ScoreConfigs struct {
	Data []ScoreConfig     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// ScoreDataType defines model for ScoreDataType.
type ScoreDataType string

// ScoreEvent defines model for ScoreEvent.
type ScoreEvent = BaseEvent

// ScoreSource defines model for ScoreSource.
type ScoreSource string

// Scores defines model for Scores.
type Scores struct {
	Data []Score           `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// Session defines model for Session.
type Session struct {
	CreatedAt time.Time `json:"createdAt"`
	Id        string    `json:"id"`
	ProjectId string    `json:"projectId"`
}

// SessionWithTraces defines model for SessionWithTraces.
type SessionWithTraces = Session

// TextPrompt defines model for TextPrompt.
type TextPrompt = BasePrompt

// Trace defines model for Trace.
type Trace struct {
	// Id The unique identifier of a trace
	Id       string       `json:"id"`
	Input    *interface{} `json:"input"`
	Metadata *interface{} `json:"metadata"`
	Name     *string      `json:"name"`
	Output   *interface{} `json:"output"`

	// Public Public traces are accessible via url without login
	Public    *bool     `json:"public"`
	Release   *string   `json:"release"`
	SessionId *string   `json:"sessionId"`
	Tags      *[]string `json:"tags"`
	Timestamp time.Time `json:"timestamp"`
	UserId    *string   `json:"userId"`
	Version   *string   `json:"version"`
}

// TraceBody defines model for TraceBody.
type TraceBody struct {
	Id       *string      `json:"id"`
	Input    *interface{} `json:"input"`
	Metadata *interface{} `json:"metadata"`
	Name     *string      `json:"name"`
	Output   *interface{} `json:"output"`

	// Public Make trace publicly accessible via url
	Public    *bool      `json:"public"`
	Release   *string    `json:"release"`
	SessionId *string    `json:"sessionId"`
	Tags      *[]string  `json:"tags"`
	Timestamp *time.Time `json:"timestamp"`
	UserId    *string    `json:"userId"`
	Version   *string    `json:"version"`
}

// TraceEvent defines model for TraceEvent.
type TraceEvent = BaseEvent

// TraceWithDetails defines model for TraceWithDetails.
type TraceWithDetails = Trace

// TraceWithFullDetails defines model for TraceWithFullDetails.
type TraceWithFullDetails = Trace

// Traces defines model for Traces.
type Traces struct {
	Data []TraceWithDetails `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// UpdateEventBody defines model for UpdateEventBody.
type UpdateEventBody = OptionalObservationBody

// UpdateGenerationBody defines model for UpdateGenerationBody.
type UpdateGenerationBody = UpdateSpanBody

// UpdateGenerationEvent defines model for UpdateGenerationEvent.
type UpdateGenerationEvent = BaseEvent

// UpdateObservationEvent defines model for UpdateObservationEvent.
type UpdateObservationEvent = BaseEvent

// UpdateSpanBody defines model for UpdateSpanBody.
type UpdateSpanBody = UpdateEventBody

// UpdateSpanEvent defines model for UpdateSpanEvent.
type UpdateSpanEvent = BaseEvent

// Usage Standard interface for usage and cost
type Usage struct {
	// Input Number of input units (e.g. tokens)
	Input *int `json:"input"`

	// InputCost USD input cost
	InputCost *float64 `json:"inputCost"`

	// Output Number of output units (e.g. tokens)
	Output *int `json:"output"`

	// OutputCost USD output cost
	OutputCost *float64 `json:"outputCost"`

	// Total Defaults to input+output if not set
	Total *int `json:"total"`

	// TotalCost USD total cost, defaults to input+output
	TotalCost *float64 `json:"totalCost"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// UsageByModel Daily usage of a given model. Usage corresponds to the unit set for the specific model (e.g. tokens).
type UsageByModel struct {
	CountObservations int `json:"countObservations"`
	CountTraces       int `json:"countTraces"`

	// InputUsage Total number of generation input units (e.g. tokens)
	InputUsage int     `json:"inputUsage"`
	Model      *string `json:"model"`

	// OutputUsage Total number of generation output units (e.g. tokens)
	OutputUsage int `json:"outputUsage"`

	// TotalCost Total model cost in USD
	TotalCost float64 `json:"totalCost"`

	// TotalUsage Total number of generation total units (e.g. tokens)
	TotalUsage int `json:"totalUsage"`
}

// UtilsMetaResponse defines model for utilsMetaResponse.
type UtilsMetaResponse struct {
	// Limit number of items per page
	Limit int `json:"limit"`

	// Page current page number
	Page int `json:"page"`

	// TotalItems number of total items given the current filters/selection (if any)
	TotalItems int `json:"totalItems"`

	// TotalPages number of total pages given the current limit
	TotalPages int `json:"totalPages"`
}

// DatasetItemsListParams defines parameters for DatasetItemsList.
type DatasetItemsListParams struct {
	DatasetName         *string `form:"datasetName,omitempty" json:"datasetName,omitempty"`
	SourceTraceId       *string `form:"sourceTraceId,omitempty" json:"sourceTraceId,omitempty"`
	SourceObservationId *string `form:"sourceObservationId,omitempty" json:"sourceObservationId,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DatasetsGetRunsParams defines parameters for DatasetsGetRuns.
type DatasetsGetRunsParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestionBatchJSONBody defines parameters for IngestionBatch.
type IngestionBatchJSONBody struct {
	// Batch Batch of tracing events to be ingested. Discriminated by attribute `type`.
	Batch []IngestionEvent `json:"batch"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`
}

// MetricsDailyParams defines parameters for MetricsDaily.
type MetricsDailyParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TraceName Optional filter by the name of the trace
	TraceName *string `form:"traceName,omitempty" json:"traceName,omitempty"`

	// UserId Optional filter by the userId associated with the trace
	UserId *string `form:"userId,omitempty" json:"userId,omitempty"`

	// Tags Optional filter for metrics where traces include all of these tags
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// FromTimestamp Optional filter to only include traces on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include traces before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`
}

// ModelsListParams defines parameters for ModelsList.
type ModelsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ObservationsGetManyParams defines parameters for ObservationsGetMany.
type ObservationsGetManyParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit               *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Name                *string `form:"name,omitempty" json:"name,omitempty"`
	UserId              *string `form:"userId,omitempty" json:"userId,omitempty"`
	Type                *string `form:"type,omitempty" json:"type,omitempty"`
	TraceId             *string `form:"traceId,omitempty" json:"traceId,omitempty"`
	ParentObservationId *string `form:"parentObservationId,omitempty" json:"parentObservationId,omitempty"`

	// FromStartTime Retrieve only observations with a start_time or or after this datetime (ISO 8601).
	FromStartTime *time.Time `form:"fromStartTime,omitempty" json:"fromStartTime,omitempty"`

	// ToStartTime Retrieve only observations with a start_time before this datetime (ISO 8601).
	ToStartTime *time.Time `form:"toStartTime,omitempty" json:"toStartTime,omitempty"`

	// Version Optional filter to only include observations with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ScoreConfigsGetParams defines parameters for ScoreConfigsGet.
type ScoreConfigsGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ScoreGetParams defines parameters for ScoreGet.
type ScoreGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// UserId Retrieve only scores with this userId associated to the trace.
	UserId *string `form:"userId,omitempty" json:"userId,omitempty"`

	// Name Retrieve only scores with this name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// FromTimestamp Optional filter to only include scores created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include scores created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// Source Retrieve only scores from a specific source.
	Source *ScoreSource `form:"source,omitempty" json:"source,omitempty"`

	// Operator Retrieve only scores with <operator> value.
	Operator *string `form:"operator,omitempty" json:"operator,omitempty"`

	// Value Retrieve only scores with <operator> value.
	Value *float64 `form:"value,omitempty" json:"value,omitempty"`

	// ScoreIds Comma-separated list of score IDs to limit the results to.
	ScoreIds *string `form:"scoreIds,omitempty" json:"scoreIds,omitempty"`

	// ConfigId Retrieve only scores with a specific configId.
	ConfigId *string `form:"configId,omitempty" json:"configId,omitempty"`

	// DataType Retrieve only scores with a specific dataType.
	DataType *ScoreDataType `form:"dataType,omitempty" json:"dataType,omitempty"`
}

// SessionsListParams defines parameters for SessionsList.
type SessionsListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FromTimestamp Optional filter to only include sessions created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include sessions created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`
}

// TraceListParams defines parameters for TraceList.
type TraceListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit     *int    `form:"limit,omitempty" json:"limit,omitempty"`
	UserId    *string `form:"userId,omitempty" json:"userId,omitempty"`
	Name      *string `form:"name,omitempty" json:"name,omitempty"`
	SessionId *string `form:"sessionId,omitempty" json:"sessionId,omitempty"`

	// FromTimestamp Optional filter to only include traces with a trace.timestamp on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include traces with a trace.timestamp before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// OrderBy Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Tags Only traces that include all of these tags will be returned.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Version Optional filter to only include traces with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Release Optional filter to only include traces with a certain release.
	Release *string `form:"release,omitempty" json:"release,omitempty"`
}

// DatasetsListParams defines parameters for DatasetsList.
type DatasetsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PromptsListParams defines parameters for PromptsList.
type PromptsListParams struct {
	Name  *string `form:"name,omitempty" json:"name,omitempty"`
	Label *string `form:"label,omitempty" json:"label,omitempty"`
	Tag   *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PromptsGetParams defines parameters for PromptsGet.
type PromptsGetParams struct {
	// Version Version of the prompt to be retrieved.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// Label Label of the prompt to be retrieved. Defaults to "production" if no label or version is set.
	Label *string `form:"label,omitempty" json:"label,omitempty"`
}

// DatasetItemsCreateJSONRequestBody defines body for DatasetItemsCreate for application/json ContentType.
type DatasetItemsCreateJSONRequestBody = CreateDatasetItemRequest

// DatasetRunItemsCreateJSONRequestBody defines body for DatasetRunItemsCreate for application/json ContentType.
type DatasetRunItemsCreateJSONRequestBody = CreateDatasetRunItemRequest

// IngestionBatchJSONRequestBody defines body for IngestionBatch for application/json ContentType.
type IngestionBatchJSONRequestBody IngestionBatchJSONBody

// ModelsCreateJSONRequestBody defines body for ModelsCreate for application/json ContentType.
type ModelsCreateJSONRequestBody = CreateModelRequest

// ScoreConfigsCreateJSONRequestBody defines body for ScoreConfigsCreate for application/json ContentType.
type ScoreConfigsCreateJSONRequestBody = CreateScoreConfigRequest

// ScoreCreateJSONRequestBody defines body for ScoreCreate for application/json ContentType.
type ScoreCreateJSONRequestBody = CreateScoreRequest

// DatasetsCreateJSONRequestBody defines body for DatasetsCreate for application/json ContentType.
type DatasetsCreateJSONRequestBody = CreateDatasetRequest

// PromptsCreateJSONRequestBody defines body for PromptsCreate for application/json ContentType.
type PromptsCreateJSONRequestBody = CreatePromptRequest

// AsCreatePromptRequest0 returns the union data inside the CreatePromptRequest as a CreatePromptRequest0
func (t CreatePromptRequest) AsCreatePromptRequest0() (CreatePromptRequest0, error) {
	var body CreatePromptRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest0 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest0
func (t *CreatePromptRequest) FromCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest0 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest0
func (t *CreatePromptRequest) MergeCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePromptRequest1 returns the union data inside the CreatePromptRequest as a CreatePromptRequest1
func (t CreatePromptRequest) AsCreatePromptRequest1() (CreatePromptRequest1, error) {
	var body CreatePromptRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest1 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest1
func (t *CreatePromptRequest) FromCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest1 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest1
func (t *CreatePromptRequest) MergeCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePromptRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePromptRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateScoreValue0 returns the union data inside the CreateScoreValue as a CreateScoreValue0
func (t CreateScoreValue) AsCreateScoreValue0() (CreateScoreValue0, error) {
	var body CreateScoreValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue0 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue0
func (t *CreateScoreValue) FromCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue0 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue0
func (t *CreateScoreValue) MergeCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateScoreValue1 returns the union data inside the CreateScoreValue as a CreateScoreValue1
func (t CreateScoreValue) AsCreateScoreValue1() (CreateScoreValue1, error) {
	var body CreateScoreValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue1 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue1
func (t *CreateScoreValue) FromCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue1 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue1
func (t *CreateScoreValue) MergeCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateScoreValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateScoreValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIngestionEvent0 returns the union data inside the IngestionEvent as a IngestionEvent0
func (t IngestionEvent) AsIngestionEvent0() (IngestionEvent0, error) {
	var body IngestionEvent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent0 overwrites any union data inside the IngestionEvent as the provided IngestionEvent0
func (t *IngestionEvent) FromIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent0 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent0
func (t *IngestionEvent) MergeIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent1 returns the union data inside the IngestionEvent as a IngestionEvent1
func (t IngestionEvent) AsIngestionEvent1() (IngestionEvent1, error) {
	var body IngestionEvent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent1 overwrites any union data inside the IngestionEvent as the provided IngestionEvent1
func (t *IngestionEvent) FromIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent1 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent1
func (t *IngestionEvent) MergeIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent2 returns the union data inside the IngestionEvent as a IngestionEvent2
func (t IngestionEvent) AsIngestionEvent2() (IngestionEvent2, error) {
	var body IngestionEvent2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent2 overwrites any union data inside the IngestionEvent as the provided IngestionEvent2
func (t *IngestionEvent) FromIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent2 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent2
func (t *IngestionEvent) MergeIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent3 returns the union data inside the IngestionEvent as a IngestionEvent3
func (t IngestionEvent) AsIngestionEvent3() (IngestionEvent3, error) {
	var body IngestionEvent3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent3 overwrites any union data inside the IngestionEvent as the provided IngestionEvent3
func (t *IngestionEvent) FromIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent3 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent3
func (t *IngestionEvent) MergeIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent4 returns the union data inside the IngestionEvent as a IngestionEvent4
func (t IngestionEvent) AsIngestionEvent4() (IngestionEvent4, error) {
	var body IngestionEvent4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent4 overwrites any union data inside the IngestionEvent as the provided IngestionEvent4
func (t *IngestionEvent) FromIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent4 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent4
func (t *IngestionEvent) MergeIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent5 returns the union data inside the IngestionEvent as a IngestionEvent5
func (t IngestionEvent) AsIngestionEvent5() (IngestionEvent5, error) {
	var body IngestionEvent5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent5 overwrites any union data inside the IngestionEvent as the provided IngestionEvent5
func (t *IngestionEvent) FromIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent5 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent5
func (t *IngestionEvent) MergeIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent6 returns the union data inside the IngestionEvent as a IngestionEvent6
func (t IngestionEvent) AsIngestionEvent6() (IngestionEvent6, error) {
	var body IngestionEvent6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent6 overwrites any union data inside the IngestionEvent as the provided IngestionEvent6
func (t *IngestionEvent) FromIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent6 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent6
func (t *IngestionEvent) MergeIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent7 returns the union data inside the IngestionEvent as a IngestionEvent7
func (t IngestionEvent) AsIngestionEvent7() (IngestionEvent7, error) {
	var body IngestionEvent7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent7 overwrites any union data inside the IngestionEvent as the provided IngestionEvent7
func (t *IngestionEvent) FromIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent7 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent7
func (t *IngestionEvent) MergeIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent8 returns the union data inside the IngestionEvent as a IngestionEvent8
func (t IngestionEvent) AsIngestionEvent8() (IngestionEvent8, error) {
	var body IngestionEvent8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent8 overwrites any union data inside the IngestionEvent as the provided IngestionEvent8
func (t *IngestionEvent) FromIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent8 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent8
func (t *IngestionEvent) MergeIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent9 returns the union data inside the IngestionEvent as a IngestionEvent9
func (t IngestionEvent) AsIngestionEvent9() (IngestionEvent9, error) {
	var body IngestionEvent9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent9 overwrites any union data inside the IngestionEvent as the provided IngestionEvent9
func (t *IngestionEvent) FromIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent9 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent9
func (t *IngestionEvent) MergeIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsage returns the union data inside the IngestionUsage as a Usage
func (t IngestionUsage) AsUsage() (Usage, error) {
	var body Usage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsage overwrites any union data inside the IngestionUsage as the provided Usage
func (t *IngestionUsage) FromUsage(v Usage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsage performs a merge with any union data inside the IngestionUsage, using the provided Usage
func (t *IngestionUsage) MergeUsage(v Usage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIUsage returns the union data inside the IngestionUsage as a OpenAIUsage
func (t IngestionUsage) AsOpenAIUsage() (OpenAIUsage, error) {
	var body OpenAIUsage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIUsage overwrites any union data inside the IngestionUsage as the provided OpenAIUsage
func (t *IngestionUsage) FromOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIUsage performs a merge with any union data inside the IngestionUsage, using the provided OpenAIUsage
func (t *IngestionUsage) MergeOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionUsage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionUsage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMapValue0 returns the union data inside the MapValue as a MapValue0
func (t MapValue) AsMapValue0() (MapValue0, error) {
	var body MapValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue0 overwrites any union data inside the MapValue as the provided MapValue0
func (t *MapValue) FromMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue0 performs a merge with any union data inside the MapValue, using the provided MapValue0
func (t *MapValue) MergeMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue1 returns the union data inside the MapValue as a MapValue1
func (t MapValue) AsMapValue1() (MapValue1, error) {
	var body MapValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue1 overwrites any union data inside the MapValue as the provided MapValue1
func (t *MapValue) FromMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue1 performs a merge with any union data inside the MapValue, using the provided MapValue1
func (t *MapValue) MergeMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue2 returns the union data inside the MapValue as a MapValue2
func (t MapValue) AsMapValue2() (MapValue2, error) {
	var body MapValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue2 overwrites any union data inside the MapValue as the provided MapValue2
func (t *MapValue) FromMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue2 performs a merge with any union data inside the MapValue, using the provided MapValue2
func (t *MapValue) MergeMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue3 returns the union data inside the MapValue as a MapValue3
func (t MapValue) AsMapValue3() (MapValue3, error) {
	var body MapValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue3 overwrites any union data inside the MapValue as the provided MapValue3
func (t *MapValue) FromMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue3 performs a merge with any union data inside the MapValue, using the provided MapValue3
func (t *MapValue) MergeMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MapValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MapValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrompt0 returns the union data inside the Prompt as a Prompt0
func (t Prompt) AsPrompt0() (Prompt0, error) {
	var body Prompt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt0 overwrites any union data inside the Prompt as the provided Prompt0
func (t *Prompt) FromPrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt0 performs a merge with any union data inside the Prompt, using the provided Prompt0
func (t *Prompt) MergePrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrompt1 returns the union data inside the Prompt as a Prompt1
func (t Prompt) AsPrompt1() (Prompt1, error) {
	var body Prompt1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt1 overwrites any union data inside the Prompt as the provided Prompt1
func (t *Prompt) FromPrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt1 performs a merge with any union data inside the Prompt, using the provided Prompt1
func (t *Prompt) MergePrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Prompt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Prompt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScore0 returns the union data inside the Score as a Score0
func (t Score) AsScore0() (Score0, error) {
	var body Score0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore0 overwrites any union data inside the Score as the provided Score0
func (t *Score) FromScore0(v Score0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore0 performs a merge with any union data inside the Score, using the provided Score0
func (t *Score) MergeScore0(v Score0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore1 returns the union data inside the Score as a Score1
func (t Score) AsScore1() (Score1, error) {
	var body Score1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore1 overwrites any union data inside the Score as the provided Score1
func (t *Score) FromScore1(v Score1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore1 performs a merge with any union data inside the Score, using the provided Score1
func (t *Score) MergeScore1(v Score1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore2 returns the union data inside the Score as a Score2
func (t Score) AsScore2() (Score2, error) {
	var body Score2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore2 overwrites any union data inside the Score as the provided Score2
func (t *Score) FromScore2(v Score2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore2 performs a merge with any union data inside the Score, using the provided Score2
func (t *Score) MergeScore2(v Score2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Score) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Score) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DatasetItemsList request
	DatasetItemsList(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsCreateWithBody request with any body
	DatasetItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetItemsCreate(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsGet request
	DatasetItemsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetRunItemsCreateWithBody request with any body
	DatasetRunItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetRunItemsCreate(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGetRuns request
	DatasetsGetRuns(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGetRun request
	DatasetsGetRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthHealth request
	HealthHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestionBatchWithBody request with any body
	IngestionBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestionBatch(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsDaily request
	MetricsDaily(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsList request
	ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsCreateWithBody request with any body
	ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsDelete request
	ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsGet request
	ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservationsGetMany request
	ObservationsGetMany(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservationsGet request
	ObservationsGet(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsGet request
	ProjectsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsGet request
	ScoreConfigsGet(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsCreateWithBody request with any body
	ScoreConfigsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScoreConfigsCreate(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsGetById request
	ScoreConfigsGetById(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreGet request
	ScoreGet(ctx context.Context, params *ScoreGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreCreateWithBody request with any body
	ScoreCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScoreCreate(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreDelete request
	ScoreDelete(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreGetById request
	ScoreGetById(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionsList request
	SessionsList(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionsGet request
	SessionsGet(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceList request
	TraceList(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceGet request
	TraceGet(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsList request
	DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsCreateWithBody request with any body
	DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGet request
	DatasetsGet(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsList request
	PromptsList(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsCreateWithBody request with any body
	PromptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromptsCreate(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsGet request
	PromptsGet(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DatasetItemsList(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsCreate(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetRunItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetRunItemsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetRunItemsCreate(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetRunItemsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGetRuns(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRunsRequest(c.Server, datasetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGetRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRunRequest(c.Server, datasetName, runName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestionBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestionBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestionBatch(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestionBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsDaily(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsDailyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservationsGetMany(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservationsGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservationsGet(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservationsGetRequest(c.Server, observationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsGet(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsCreate(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsGetById(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsGetByIdRequest(c.Server, configId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreGet(ctx context.Context, params *ScoreGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreCreate(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreDelete(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreDeleteRequest(c.Server, scoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreGetById(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreGetByIdRequest(c.Server, scoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionsList(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionsGet(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionsGetRequest(c.Server, sessionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceList(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceGet(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceGetRequest(c.Server, traceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGet(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRequest(c.Server, datasetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsList(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsCreate(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsGet(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsGetRequest(c.Server, promptName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDatasetItemsListRequest generates requests for DatasetItemsList
func NewDatasetItemsListRequest(server string, params *DatasetItemsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatasetName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasetName", runtime.ParamLocationQuery, *params.DatasetName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTraceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceTraceId", runtime.ParamLocationQuery, *params.SourceTraceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceObservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceObservationId", runtime.ParamLocationQuery, *params.SourceObservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetItemsCreateRequest calls the generic DatasetItemsCreate builder with application/json body
func NewDatasetItemsCreateRequest(server string, body DatasetItemsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetItemsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetItemsCreateRequestWithBody generates requests for DatasetItemsCreate with any type of body
func NewDatasetItemsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetItemsGetRequest generates requests for DatasetItemsGet
func NewDatasetItemsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetRunItemsCreateRequest calls the generic DatasetRunItemsCreate builder with application/json body
func NewDatasetRunItemsCreateRequest(server string, body DatasetRunItemsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetRunItemsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetRunItemsCreateRequestWithBody generates requests for DatasetRunItemsCreate with any type of body
func NewDatasetRunItemsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-run-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsGetRunsRequest generates requests for DatasetsGetRuns
func NewDatasetsGetRunsRequest(server string, datasetName string, params *DatasetsGetRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/datasets/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsGetRunRequest generates requests for DatasetsGetRun
func NewDatasetsGetRunRequest(server string, datasetName string, runName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runName", runtime.ParamLocationPath, runName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/datasets/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthHealthRequest generates requests for HealthHealth
func NewHealthHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIngestionBatchRequest calls the generic IngestionBatch builder with application/json body
func NewIngestionBatchRequest(server string, body IngestionBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestionBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewIngestionBatchRequestWithBody generates requests for IngestionBatch with any type of body
func NewIngestionBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/ingestion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricsDailyRequest generates requests for MetricsDaily
func NewMetricsDailyRequest(server string, params *MetricsDailyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/metrics/daily")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TraceName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "traceName", runtime.ParamLocationQuery, *params.TraceName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsListRequest generates requests for ModelsList
func NewModelsListRequest(server string, params *ModelsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsCreateRequest calls the generic ModelsCreate builder with application/json body
func NewModelsCreateRequest(server string, body ModelsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewModelsCreateRequestWithBody generates requests for ModelsCreate with any type of body
func NewModelsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelsDeleteRequest generates requests for ModelsDelete
func NewModelsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsGetRequest generates requests for ModelsGet
func NewModelsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservationsGetManyRequest generates requests for ObservationsGetMany
func NewObservationsGetManyRequest(server string, params *ObservationsGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/observations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TraceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "traceId", runtime.ParamLocationQuery, *params.TraceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentObservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentObservationId", runtime.ParamLocationQuery, *params.ParentObservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromStartTime", runtime.ParamLocationQuery, *params.FromStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toStartTime", runtime.ParamLocationQuery, *params.ToStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservationsGetRequest generates requests for ObservationsGet
func NewObservationsGetRequest(server string, observationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "observationId", runtime.ParamLocationPath, observationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/observations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsGetRequest generates requests for ProjectsGet
func NewProjectsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreConfigsGetRequest generates requests for ScoreConfigsGet
func NewScoreConfigsGetRequest(server string, params *ScoreConfigsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreConfigsCreateRequest calls the generic ScoreConfigsCreate builder with application/json body
func NewScoreConfigsCreateRequest(server string, body ScoreConfigsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScoreConfigsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScoreConfigsCreateRequestWithBody generates requests for ScoreConfigsCreate with any type of body
func NewScoreConfigsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScoreConfigsGetByIdRequest generates requests for ScoreConfigsGetById
func NewScoreConfigsGetByIdRequest(server string, configId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configId", runtime.ParamLocationPath, configId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreGetRequest generates requests for ScoreGet
func NewScoreGetRequest(server string, params *ScoreGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operator", runtime.ParamLocationQuery, *params.Operator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScoreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scoreIds", runtime.ParamLocationQuery, *params.ScoreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfigId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configId", runtime.ParamLocationQuery, *params.ConfigId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DataType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataType", runtime.ParamLocationQuery, *params.DataType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreCreateRequest calls the generic ScoreCreate builder with application/json body
func NewScoreCreateRequest(server string, body ScoreCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScoreCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScoreCreateRequestWithBody generates requests for ScoreCreate with any type of body
func NewScoreCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScoreDeleteRequest generates requests for ScoreDelete
func NewScoreDeleteRequest(server string, scoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scoreId", runtime.ParamLocationPath, scoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreGetByIdRequest generates requests for ScoreGetById
func NewScoreGetByIdRequest(server string, scoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scoreId", runtime.ParamLocationPath, scoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSessionsListRequest generates requests for SessionsList
func NewSessionsListRequest(server string, params *SessionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSessionsGetRequest generates requests for SessionsGet
func NewSessionsGetRequest(server string, sessionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceListRequest generates requests for TraceList
func NewTraceListRequest(server string, params *TraceListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sessionId", runtime.ParamLocationQuery, *params.SessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Release != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release", runtime.ParamLocationQuery, *params.Release); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceGetRequest generates requests for TraceGet
func NewTraceGetRequest(server string, traceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "traceId", runtime.ParamLocationPath, traceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsListRequest generates requests for DatasetsList
func NewDatasetsListRequest(server string, params *DatasetsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsCreateRequest calls the generic DatasetsCreate builder with application/json body
func NewDatasetsCreateRequest(server string, body DatasetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetsCreateRequestWithBody generates requests for DatasetsCreate with any type of body
func NewDatasetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsGetRequest generates requests for DatasetsGet
func NewDatasetsGetRequest(server string, datasetName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromptsListRequest generates requests for PromptsList
func NewPromptsListRequest(server string, params *PromptsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromptsCreateRequest calls the generic PromptsCreate builder with application/json body
func NewPromptsCreateRequest(server string, body PromptsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromptsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPromptsCreateRequestWithBody generates requests for PromptsCreate with any type of body
func NewPromptsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPromptsGetRequest generates requests for PromptsGet
func NewPromptsGetRequest(server string, promptName string, params *PromptsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "promptName", runtime.ParamLocationPath, promptName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DatasetItemsListWithResponse request
	DatasetItemsListWithResponse(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*DatasetItemsListResponse, error)

	// DatasetItemsCreateWithBodyWithResponse request with any body
	DatasetItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error)

	DatasetItemsCreateWithResponse(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error)

	// DatasetItemsGetWithResponse request
	DatasetItemsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsGetResponse, error)

	// DatasetRunItemsCreateWithBodyWithResponse request with any body
	DatasetRunItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error)

	DatasetRunItemsCreateWithResponse(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error)

	// DatasetsGetRunsWithResponse request
	DatasetsGetRunsWithResponse(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*DatasetsGetRunsResponse, error)

	// DatasetsGetRunWithResponse request
	DatasetsGetRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsGetRunResponse, error)

	// HealthHealthWithResponse request
	HealthHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthHealthResponse, error)

	// IngestionBatchWithBodyWithResponse request with any body
	IngestionBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error)

	IngestionBatchWithResponse(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error)

	// MetricsDailyWithResponse request
	MetricsDailyWithResponse(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*MetricsDailyResponse, error)

	// ModelsListWithResponse request
	ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error)

	// ModelsCreateWithBodyWithResponse request with any body
	ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	// ModelsDeleteWithResponse request
	ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error)

	// ModelsGetWithResponse request
	ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error)

	// ObservationsGetManyWithResponse request
	ObservationsGetManyWithResponse(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*ObservationsGetManyResponse, error)

	// ObservationsGetWithResponse request
	ObservationsGetWithResponse(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*ObservationsGetResponse, error)

	// ProjectsGetWithResponse request
	ProjectsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error)

	// ScoreConfigsGetWithResponse request
	ScoreConfigsGetWithResponse(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*ScoreConfigsGetResponse, error)

	// ScoreConfigsCreateWithBodyWithResponse request with any body
	ScoreConfigsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error)

	ScoreConfigsCreateWithResponse(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error)

	// ScoreConfigsGetByIdWithResponse request
	ScoreConfigsGetByIdWithResponse(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*ScoreConfigsGetByIdResponse, error)

	// ScoreGetWithResponse request
	ScoreGetWithResponse(ctx context.Context, params *ScoreGetParams, reqEditors ...RequestEditorFn) (*ScoreGetResponse, error)

	// ScoreCreateWithBodyWithResponse request with any body
	ScoreCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error)

	ScoreCreateWithResponse(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error)

	// ScoreDeleteWithResponse request
	ScoreDeleteWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreDeleteResponse, error)

	// ScoreGetByIdWithResponse request
	ScoreGetByIdWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreGetByIdResponse, error)

	// SessionsListWithResponse request
	SessionsListWithResponse(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*SessionsListResponse, error)

	// SessionsGetWithResponse request
	SessionsGetWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*SessionsGetResponse, error)

	// TraceListWithResponse request
	TraceListWithResponse(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*TraceListResponse, error)

	// TraceGetWithResponse request
	TraceGetWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceGetResponse, error)

	// DatasetsListWithResponse request
	DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error)

	// DatasetsCreateWithBodyWithResponse request with any body
	DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	// DatasetsGetWithResponse request
	DatasetsGetWithResponse(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error)

	// PromptsListWithResponse request
	PromptsListWithResponse(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*PromptsListResponse, error)

	// PromptsCreateWithBodyWithResponse request with any body
	PromptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error)

	PromptsCreateWithResponse(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error)

	// PromptsGetWithResponse request
	PromptsGetWithResponse(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*PromptsGetResponse, error)
}

type DatasetItemsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasetItems
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetRunItemsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetRunItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetRunItemsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetRunItemsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasetRuns
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetRunWithItems
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r HealthHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestionBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IngestionResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r IngestionBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestionBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsDailyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyMetrics
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MetricsDailyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsDailyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedModels
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservationsGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservationsViews
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ObservationsGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservationsGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservationsView
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ObservationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Projects
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfigs
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfig
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfig
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scores
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateScoreResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Score
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSessions
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r SessionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionWithTraces
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r SessionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TraceWithFullDetails
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasets
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dataset
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dataset
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PromptMetaListResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Prompt
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Prompt
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DatasetItemsListWithResponse request returning *DatasetItemsListResponse
func (c *ClientWithResponses) DatasetItemsListWithResponse(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*DatasetItemsListResponse, error) {
	rsp, err := c.DatasetItemsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsListResponse(rsp)
}

// DatasetItemsCreateWithBodyWithResponse request with arbitrary body returning *DatasetItemsCreateResponse
func (c *ClientWithResponses) DatasetItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error) {
	rsp, err := c.DatasetItemsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetItemsCreateWithResponse(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error) {
	rsp, err := c.DatasetItemsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsCreateResponse(rsp)
}

// DatasetItemsGetWithResponse request returning *DatasetItemsGetResponse
func (c *ClientWithResponses) DatasetItemsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsGetResponse, error) {
	rsp, err := c.DatasetItemsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsGetResponse(rsp)
}

// DatasetRunItemsCreateWithBodyWithResponse request with arbitrary body returning *DatasetRunItemsCreateResponse
func (c *ClientWithResponses) DatasetRunItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error) {
	rsp, err := c.DatasetRunItemsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetRunItemsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetRunItemsCreateWithResponse(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error) {
	rsp, err := c.DatasetRunItemsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetRunItemsCreateResponse(rsp)
}

// DatasetsGetRunsWithResponse request returning *DatasetsGetRunsResponse
func (c *ClientWithResponses) DatasetsGetRunsWithResponse(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*DatasetsGetRunsResponse, error) {
	rsp, err := c.DatasetsGetRuns(ctx, datasetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetRunsResponse(rsp)
}

// DatasetsGetRunWithResponse request returning *DatasetsGetRunResponse
func (c *ClientWithResponses) DatasetsGetRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsGetRunResponse, error) {
	rsp, err := c.DatasetsGetRun(ctx, datasetName, runName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetRunResponse(rsp)
}

// HealthHealthWithResponse request returning *HealthHealthResponse
func (c *ClientWithResponses) HealthHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthHealthResponse, error) {
	rsp, err := c.HealthHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthHealthResponse(rsp)
}

// IngestionBatchWithBodyWithResponse request with arbitrary body returning *IngestionBatchResponse
func (c *ClientWithResponses) IngestionBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error) {
	rsp, err := c.IngestionBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestionBatchResponse(rsp)
}

func (c *ClientWithResponses) IngestionBatchWithResponse(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error) {
	rsp, err := c.IngestionBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestionBatchResponse(rsp)
}

// MetricsDailyWithResponse request returning *MetricsDailyResponse
func (c *ClientWithResponses) MetricsDailyWithResponse(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*MetricsDailyResponse, error) {
	rsp, err := c.MetricsDaily(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsDailyResponse(rsp)
}

// ModelsListWithResponse request returning *ModelsListResponse
func (c *ClientWithResponses) ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error) {
	rsp, err := c.ModelsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsListResponse(rsp)
}

// ModelsCreateWithBodyWithResponse request with arbitrary body returning *ModelsCreateResponse
func (c *ClientWithResponses) ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

func (c *ClientWithResponses) ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

// ModelsDeleteWithResponse request returning *ModelsDeleteResponse
func (c *ClientWithResponses) ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error) {
	rsp, err := c.ModelsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsDeleteResponse(rsp)
}

// ModelsGetWithResponse request returning *ModelsGetResponse
func (c *ClientWithResponses) ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error) {
	rsp, err := c.ModelsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsGetResponse(rsp)
}

// ObservationsGetManyWithResponse request returning *ObservationsGetManyResponse
func (c *ClientWithResponses) ObservationsGetManyWithResponse(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*ObservationsGetManyResponse, error) {
	rsp, err := c.ObservationsGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservationsGetManyResponse(rsp)
}

// ObservationsGetWithResponse request returning *ObservationsGetResponse
func (c *ClientWithResponses) ObservationsGetWithResponse(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*ObservationsGetResponse, error) {
	rsp, err := c.ObservationsGet(ctx, observationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservationsGetResponse(rsp)
}

// ProjectsGetWithResponse request returning *ProjectsGetResponse
func (c *ClientWithResponses) ProjectsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error) {
	rsp, err := c.ProjectsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsGetResponse(rsp)
}

// ScoreConfigsGetWithResponse request returning *ScoreConfigsGetResponse
func (c *ClientWithResponses) ScoreConfigsGetWithResponse(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*ScoreConfigsGetResponse, error) {
	rsp, err := c.ScoreConfigsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsGetResponse(rsp)
}

// ScoreConfigsCreateWithBodyWithResponse request with arbitrary body returning *ScoreConfigsCreateResponse
func (c *ClientWithResponses) ScoreConfigsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error) {
	rsp, err := c.ScoreConfigsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsCreateResponse(rsp)
}

func (c *ClientWithResponses) ScoreConfigsCreateWithResponse(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error) {
	rsp, err := c.ScoreConfigsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsCreateResponse(rsp)
}

// ScoreConfigsGetByIdWithResponse request returning *ScoreConfigsGetByIdResponse
func (c *ClientWithResponses) ScoreConfigsGetByIdWithResponse(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*ScoreConfigsGetByIdResponse, error) {
	rsp, err := c.ScoreConfigsGetById(ctx, configId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsGetByIdResponse(rsp)
}

// ScoreGetWithResponse request returning *ScoreGetResponse
func (c *ClientWithResponses) ScoreGetWithResponse(ctx context.Context, params *ScoreGetParams, reqEditors ...RequestEditorFn) (*ScoreGetResponse, error) {
	rsp, err := c.ScoreGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreGetResponse(rsp)
}

// ScoreCreateWithBodyWithResponse request with arbitrary body returning *ScoreCreateResponse
func (c *ClientWithResponses) ScoreCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error) {
	rsp, err := c.ScoreCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreCreateResponse(rsp)
}

func (c *ClientWithResponses) ScoreCreateWithResponse(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error) {
	rsp, err := c.ScoreCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreCreateResponse(rsp)
}

// ScoreDeleteWithResponse request returning *ScoreDeleteResponse
func (c *ClientWithResponses) ScoreDeleteWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreDeleteResponse, error) {
	rsp, err := c.ScoreDelete(ctx, scoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreDeleteResponse(rsp)
}

// ScoreGetByIdWithResponse request returning *ScoreGetByIdResponse
func (c *ClientWithResponses) ScoreGetByIdWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreGetByIdResponse, error) {
	rsp, err := c.ScoreGetById(ctx, scoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreGetByIdResponse(rsp)
}

// SessionsListWithResponse request returning *SessionsListResponse
func (c *ClientWithResponses) SessionsListWithResponse(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*SessionsListResponse, error) {
	rsp, err := c.SessionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionsListResponse(rsp)
}

// SessionsGetWithResponse request returning *SessionsGetResponse
func (c *ClientWithResponses) SessionsGetWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*SessionsGetResponse, error) {
	rsp, err := c.SessionsGet(ctx, sessionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionsGetResponse(rsp)
}

// TraceListWithResponse request returning *TraceListResponse
func (c *ClientWithResponses) TraceListWithResponse(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*TraceListResponse, error) {
	rsp, err := c.TraceList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceListResponse(rsp)
}

// TraceGetWithResponse request returning *TraceGetResponse
func (c *ClientWithResponses) TraceGetWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceGetResponse, error) {
	rsp, err := c.TraceGet(ctx, traceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceGetResponse(rsp)
}

// DatasetsListWithResponse request returning *DatasetsListResponse
func (c *ClientWithResponses) DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error) {
	rsp, err := c.DatasetsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsListResponse(rsp)
}

// DatasetsCreateWithBodyWithResponse request with arbitrary body returning *DatasetsCreateResponse
func (c *ClientWithResponses) DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

// DatasetsGetWithResponse request returning *DatasetsGetResponse
func (c *ClientWithResponses) DatasetsGetWithResponse(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error) {
	rsp, err := c.DatasetsGet(ctx, datasetName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetResponse(rsp)
}

// PromptsListWithResponse request returning *PromptsListResponse
func (c *ClientWithResponses) PromptsListWithResponse(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*PromptsListResponse, error) {
	rsp, err := c.PromptsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsListResponse(rsp)
}

// PromptsCreateWithBodyWithResponse request with arbitrary body returning *PromptsCreateResponse
func (c *ClientWithResponses) PromptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error) {
	rsp, err := c.PromptsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsCreateResponse(rsp)
}

func (c *ClientWithResponses) PromptsCreateWithResponse(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error) {
	rsp, err := c.PromptsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsCreateResponse(rsp)
}

// PromptsGetWithResponse request returning *PromptsGetResponse
func (c *ClientWithResponses) PromptsGetWithResponse(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*PromptsGetResponse, error) {
	rsp, err := c.PromptsGet(ctx, promptName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsGetResponse(rsp)
}

// ParseDatasetItemsListResponse parses an HTTP response from a DatasetItemsListWithResponse call
func ParseDatasetItemsListResponse(rsp *http.Response) (*DatasetItemsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasetItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsCreateResponse parses an HTTP response from a DatasetItemsCreateWithResponse call
func ParseDatasetItemsCreateResponse(rsp *http.Response) (*DatasetItemsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsGetResponse parses an HTTP response from a DatasetItemsGetWithResponse call
func ParseDatasetItemsGetResponse(rsp *http.Response) (*DatasetItemsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetRunItemsCreateResponse parses an HTTP response from a DatasetRunItemsCreateWithResponse call
func ParseDatasetRunItemsCreateResponse(rsp *http.Response) (*DatasetRunItemsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetRunItemsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetRunItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetRunsResponse parses an HTTP response from a DatasetsGetRunsWithResponse call
func ParseDatasetsGetRunsResponse(rsp *http.Response) (*DatasetsGetRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasetRuns
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetRunResponse parses an HTTP response from a DatasetsGetRunWithResponse call
func ParseDatasetsGetRunResponse(rsp *http.Response) (*DatasetsGetRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetRunWithItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseHealthHealthResponse parses an HTTP response from a HealthHealthWithResponse call
func ParseHealthHealthResponse(rsp *http.Response) (*HealthHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseIngestionBatchResponse parses an HTTP response from a IngestionBatchWithResponse call
func ParseIngestionBatchResponse(rsp *http.Response) (*IngestionBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestionBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IngestionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMetricsDailyResponse parses an HTTP response from a MetricsDailyWithResponse call
func ParseMetricsDailyResponse(rsp *http.Response) (*MetricsDailyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsDailyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsListResponse parses an HTTP response from a ModelsListWithResponse call
func ParseModelsListResponse(rsp *http.Response) (*ModelsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedModels
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsCreateResponse parses an HTTP response from a ModelsCreateWithResponse call
func ParseModelsCreateResponse(rsp *http.Response) (*ModelsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsDeleteResponse parses an HTTP response from a ModelsDeleteWithResponse call
func ParseModelsDeleteResponse(rsp *http.Response) (*ModelsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsGetResponse parses an HTTP response from a ModelsGetWithResponse call
func ParseModelsGetResponse(rsp *http.Response) (*ModelsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseObservationsGetManyResponse parses an HTTP response from a ObservationsGetManyWithResponse call
func ParseObservationsGetManyResponse(rsp *http.Response) (*ObservationsGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservationsGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservationsViews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseObservationsGetResponse parses an HTTP response from a ObservationsGetWithResponse call
func ParseObservationsGetResponse(rsp *http.Response) (*ObservationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservationsView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsGetResponse parses an HTTP response from a ProjectsGetWithResponse call
func ParseProjectsGetResponse(rsp *http.Response) (*ProjectsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Projects
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsGetResponse parses an HTTP response from a ScoreConfigsGetWithResponse call
func ParseScoreConfigsGetResponse(rsp *http.Response) (*ScoreConfigsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfigs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsCreateResponse parses an HTTP response from a ScoreConfigsCreateWithResponse call
func ParseScoreConfigsCreateResponse(rsp *http.Response) (*ScoreConfigsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsGetByIdResponse parses an HTTP response from a ScoreConfigsGetByIdWithResponse call
func ParseScoreConfigsGetByIdResponse(rsp *http.Response) (*ScoreConfigsGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreGetResponse parses an HTTP response from a ScoreGetWithResponse call
func ParseScoreGetResponse(rsp *http.Response) (*ScoreGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreCreateResponse parses an HTTP response from a ScoreCreateWithResponse call
func ParseScoreCreateResponse(rsp *http.Response) (*ScoreCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateScoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreDeleteResponse parses an HTTP response from a ScoreDeleteWithResponse call
func ParseScoreDeleteResponse(rsp *http.Response) (*ScoreDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreGetByIdResponse parses an HTTP response from a ScoreGetByIdWithResponse call
func ParseScoreGetByIdResponse(rsp *http.Response) (*ScoreGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Score
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSessionsListResponse parses an HTTP response from a SessionsListWithResponse call
func ParseSessionsListResponse(rsp *http.Response) (*SessionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSessions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSessionsGetResponse parses an HTTP response from a SessionsGetWithResponse call
func ParseSessionsGetResponse(rsp *http.Response) (*SessionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionWithTraces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceListResponse parses an HTTP response from a TraceListWithResponse call
func ParseTraceListResponse(rsp *http.Response) (*TraceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceGetResponse parses an HTTP response from a TraceGetWithResponse call
func ParseTraceGetResponse(rsp *http.Response) (*TraceGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TraceWithFullDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsListResponse parses an HTTP response from a DatasetsListWithResponse call
func ParseDatasetsListResponse(rsp *http.Response) (*DatasetsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsCreateResponse parses an HTTP response from a DatasetsCreateWithResponse call
func ParseDatasetsCreateResponse(rsp *http.Response) (*DatasetsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetResponse parses an HTTP response from a DatasetsGetWithResponse call
func ParseDatasetsGetResponse(rsp *http.Response) (*DatasetsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsListResponse parses an HTTP response from a PromptsListWithResponse call
func ParsePromptsListResponse(rsp *http.Response) (*PromptsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PromptMetaListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsCreateResponse parses an HTTP response from a PromptsCreateWithResponse call
func ParsePromptsCreateResponse(rsp *http.Response) (*PromptsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Prompt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsGetResponse parses an HTTP response from a PromptsGetWithResponse call
func ParsePromptsGetResponse(rsp *http.Response) (*PromptsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Prompt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}
